(*
    Copyright David C. J. Matthews 2016-17

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License version 2.1 as published by the Free Software Foundation.
    
    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.
    
    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*)

functor X86ICodeTransform(
    structure ICODE: ICodeSig
    structure DEBUG: DEBUGSIG
    structure CODEGEN: X86ICODEGENERATESIG
    structure IDENTIFY: X86IDENTIFYREFSSIG
    structure CONFLICTSETS: X86GETCONFLICTSETSIG
    structure PUSHREGISTERS: X86PUSHREGISTERSIG
    structure PRETTY: PRETTYSIG
    structure INTSET: INTSETSIG
    sharing ICODE.Sharing = CODEGEN.Sharing = IDENTIFY.Sharing = CONFLICTSETS.Sharing = PUSHREGISTERS.Sharing = INTSET
) : X86ICODETRANSFORMSIG
=
struct
    open ICODE
    open Address
    open IDENTIFY
    open CONFLICTSETS
    open PUSHREGISTERS
    open INTSET
    open CODEGEN
    
    exception InternalError = Misc.InternalError
    
    (* Find out the registers that need to be pushed to the stack, if any.
       We include those marked as "must push" because we need to save them across a
       function call or handler and also any we need to push because the set of active
       registers is more than the number of general registers we have.  This second case
       involves choosing suitable registers and is a first attempt to check we have enough
       registers.  We can also get a failure in codeExtended when we actually allocate
       the registers. *)
    fun spillRegisters(identified: extendedBasicBlock vector, regStates: regState vector) =
    let
        val maxPRegs = Vector.length regStates
        val pushArray = Array.array(maxPRegs, false)

        (* Mark anything already marked as "must push" unless it's already on the stack *)
        local
            fun checkPush(i, {pushState=MustPush, prop=RegPropGeneral, ...}) =
                Array.update(pushArray, i, true)
            |   checkPush _ = ()
        in
            val () = Vector.appi checkPush regStates
        end
        
        (* Make a list of all the active sets ignoring those marked to be pushed.
           Do that first because we need to know how many sets each register is in. *)
        local
            fun addToActive(r, l) =
            (
                case Vector.sub(regStates, r) of
                    {prop=RegPropStack _, ...} => l
                |   _ => if Array.sub(pushArray, r) then l else r :: l
            )
        in
            fun nowActive regs = List.foldl addToActive [] regs
        end
            fun getBlockSets(ExtendedBasicBlock{block, passThrough, ...}, sets) =
            let
                fun getSets({active, ...}, l) =
                let
                    val set = nowActive(setToList(union(active, passThrough)))
                in
                    if List.length set > nGenRegs
                    then set :: l
                    else l
                end
            in
                List.foldl getSets sets block
            end

            val activeSets = Vector.foldl getBlockSets [] identified

    in
        if null activeSets then ()
        else
        let
            (* See how many times each register appears in a set. *)
            val activeIn = Array.array(maxPRegs, 0)
            val () =
                List.app (fn regs => List.app(fn r => Array.update(activeIn, r, Array.sub(activeIn, r)+1)) regs) activeSets
            (* We want to choose the best registers to spill. *)
            fun spillSomeRegs activeSet =
            let
                (* We may have already marked some of these to push. *)
                val currentActive = nowActive activeSet
                val regCount = List.length currentActive
                fun addCosts r =
                let
                    val {active, pushState, refs, ...} = Vector.sub(regStates, r)
                in
                    case pushState of
                        MustNotPush => (r, ~1, ~1)
                    |   _ => (r, Array.sub(activeIn, r), if refs = 0 then 0 else Int.quot(active, refs))
                end
                val withCosts = List.map addCosts currentActive
                (* Order so that the earlier items are those that appear in more sets and
                   if items appear in the same number of sets those that are active
                   longer come earlier. *)
                fun compare (_, in1, a1)  (_, in2, a2) = if in1 > in2 then true else if in1 < in2 then false else a1 > a2
                val sorted = Misc.quickSort compare withCosts

                fun markAsPush([], _) = ()
                |   markAsPush((reg, _, _) :: regs, n) =
                    if n <= 0
                    then ()
                    else
                    let
                        val {pushState, prop, ...} = Vector.sub(regStates, reg)
                        val _ = case pushState of MustNotPush => raise InternalError "markAsPush" | _ => ()
                        val _ = case prop of RegPropStack _ => raise InternalError "markAsPush" | _ => ()
                    in
                        Array.update(pushArray, reg, true);
                        markAsPush(regs, n-1)
                    end
            in
                markAsPush(sorted, regCount-nGenRegs)
            end
        in
            List.app spillSomeRegs activeSets
        end;
        (* Return the vector showing those that must be pushed. *)
        Array.vector pushArray
    end
     
    type triple = {instr: x86ICode, current: intSet, active: intSet}

    fun codeICodeFunctionToX86{blocks, functionName, pregProps, argRegsUsed, hasFullClosure, debugSwitches, ...} =
    let
       (*val maxPRegs = Vector.length pregProps*)
        val icodeTabs = [8, 20, 60]
        val wantPrintCode = DEBUG.getParameter DEBUG.icodeTag debugSwitches
        
        fun printCode identifiedCode =
            (* Print the code before the transformation. *)
            let
                val printStream = PRETTY.getSimplePrinter(debugSwitches, icodeTabs)
            in
                printStream(functionName ^ "\n");
                printICodeAbstract(identifiedCode, printStream);
                printStream "\n"
            end
        
        fun printConflicts(regStates: conflictState vector) =
            let
                val printStream = PRETTY.getSimplePrinter(debugSwitches, icodeTabs)

                fun printRegs([], _) = ()
                |   printRegs(_, 0) = printStream "..."
                |   printRegs([i], _) = printStream(Int.toString i)
                |   printRegs(i::l, n) = (printStream(Int.toString i ^ ","); printRegs(l, n-1))
                
                fun printRegData(i, { conflicts, ... }) =
                (
                    printStream (Int.toString i ^ "\t");
                    printStream ("Conflicts="); printRegs(setToList conflicts, 20);
                    printStream "\n"
                )
            in
                Vector.appi printRegData regStates
            end

        fun processCode(basicBlocks: basicBlock vector, pregProps: regProperty vector, maxStack, passes) =
        let
            val () =
                if wantPrintCode
                then printCode basicBlocks
                else ()
            (* First pass - identify register use patterns *)
            val (identified, regStates) = identifyRegisters(basicBlocks, pregProps)
            val regsToSpill = spillRegisters(identified, regStates)
            val needPhase2 = Vector.exists(fn t => t) regsToSpill
            val (needPhase2, regsToSpill) =
                if needPhase2 orelse passes <> 0 then (needPhase2, regsToSpill)
                else (true, Vector.tabulate(Vector.length pregProps, fn _ => false))
                
        in
            if needPhase2
            then
            let
                (* Push those registers we need to.  This also adds and renumbers pregs
                   and may add labels. *)
                val {code=postPushCode, pregProps=regPropsPhase2, maxStack=maxStackPhase2} =
                    addRegisterPushes{code=identified, pushVec=regsToSpill, pregProps=pregProps}
            in
                (* And reprocess. *)
                processCode(postPushCode, regPropsPhase2, maxStackPhase2, passes+1)
            end
            else
            let
                val maxPRegs = Vector.length regStates
                fun selectARegisterToSpill active =
                let
                    fun chooseReg([], bestReg, _) = bestReg
                    |   chooseReg(reg::regs, bestReg, bestCost) =
                        let
                            val {active, pushState, refs, prop, ...} = Vector.sub(regStates, reg)
                            val cost = if refs = 0 then 0 else Int.quot(active, refs)
                        in
                            case (pushState, prop) of
                                (MustNotPush, _) => chooseReg(regs, bestReg, bestCost)
                            |   (_, RegPropStack _) => chooseReg(regs, bestReg, bestCost)
                            |   (_, RegPropCache) => reg (* Pick the first cache reg. *)
                            |   _ =>
                                if cost >= bestCost
                                then chooseReg(regs, reg, active)
                                else chooseReg(regs, bestReg, bestCost)
                        end
                    val choice = chooseReg(setToList active, ~1, 0)
                    val _ = choice >= 0 orelse raise InternalError "chooseReg"
                in
                    Vector.tabulate(maxPRegs, fn i => i = choice)
                end
                (* Now get the conflict sets. *)
                val conflictSets = getConflictStates(identified, maxPRegs)
                local
                    fun mapFromExtended(ExtendedBasicBlock{block, flow, ...}) =
                        BasicBlock{block=List.map #instr block, flow=flow}
                in
                    val () =
                        if wantPrintCode then (printCode(Vector.map mapFromExtended identified); printConflicts conflictSets) else ()
                end
            in
                icodeToX86Code{blocks=identified, functionName=functionName, regStates=conflictSets, regProps=pregProps,
                               stackRequired=maxStack, argRegsUsed=argRegsUsed, hasFullClosure=hasFullClosure, debugSwitches=debugSwitches}
                    handle RegisterOverflow activeSet =>
                    let
                        val regsToSpill = selectARegisterToSpill activeSet
                        val {code=postPushCode, pregProps=pregPropsPhase2, maxStack=maxStackPhase2} =
                            addRegisterPushes{code=identified, pushVec=regsToSpill, pregProps=pregProps}
                    in
                        processCode(postPushCode, pregPropsPhase2, maxStackPhase2, passes+1)
                    end
            end
        end

    in
        processCode(blocks, pregProps, 0 (* Should include handlers and containers. *), 0)
    end
    structure Sharing =
    struct
        type preg       = preg
        and reg         = reg
        and basicBlock  = basicBlock
        and regProperty = regProperty
    end
end;
