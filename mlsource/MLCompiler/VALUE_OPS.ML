(*
    Copyright (c) 2000
        Cambridge University Technical Services Limited

    Modified David C.J. Matthews 2008-9, 2013, 2015-16, 2020-21, 2025.

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License version 2.1 as published by the Free Software Foundation.
    
    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.
    
    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*)

(*
    Title:      Operations on global and local values.
    Author:     Dave Matthews, Cambridge University Computer Laboratory
    Copyright   Cambridge University 1986
*)

functor VALUE_OPS (

structure LEX : LEXSIG;
structure CODETREE : CODETREE
structure STRUCTVALS : STRUCTVALSIG;
structure TYPESTRUCT : TYPETREESIG

structure UNIVERSALTABLE:
sig
    type universal = Universal.universal
    type univTable
    val app: (string * universal -> unit) -> univTable -> unit
end;

structure DEBUG : DEBUG

structure MISC :
sig
    exception InternalError of string; (* compiler error *)
    exception Conversion of string     (* string to int conversion failure *)

    val quickSort : ('a -> 'a -> bool) -> 'a list -> 'a list
end;

structure PRETTY : PRETTY
structure ADDRESS : AddressSig

structure UTILITIES :
sig
  val splitString: string -> { first:string,second:string }
end;

structure COPIER: COPIERSIG

structure TYPEIDCODE: TYPEIDCODESIG

structure DATATYPEREP: DATATYPEREPSIG

sharing STRUCTVALS.Sharing = TYPESTRUCT.Sharing = LEX.Sharing = PRETTY.Sharing
      = COPIER.Sharing = CODETREE.Sharing = ADDRESS = UNIVERSALTABLE = MISC
      = TYPEIDCODE.Sharing = DATATYPEREP.Sharing

) : VALUEOPSSIG =

struct
  open MISC; 
  open PRETTY;
  
  open LEX;
  open CODETREE;
  open TYPESTRUCT; (* Open this first because unitType is in STRUCTVALS as well. *)
  open Universal; (* for tag etc. *)
  open STRUCTVALS;
  open DEBUG;
  open ADDRESS;
  open UTILITIES;
  open TYPEIDCODE
  open COPIER
  open DATATYPEREP
  
    (* Functions to construct the values. *)
  
    fun makeValueConstr (name, typeOf, nullary, constrs, access, locations) : values =
        Value
        { 
          name    = name,
          typeOf  = typeOf,
          access  = access,
          class   = Constructor { nullary = nullary, ofConstrs = constrs },
          locations = locations,
          references = NONE
        }

    fun mkGconstr (name, typeof, code, nullary, constrs, location) =
       makeValueConstr (name, typeof, nullary, constrs, Global code, location);

    (* Global variable *)
    fun mkGvar (name, typeOf, code, locations) : values =
        Value{ name = name, typeOf = typeOf, access = Global code, class = ValBound,
            locations = locations, references = NONE }

    (* Local variable - Generated by the second pass. *)
    local
        fun makeLocalV class (name, typeOf, locations) =
            Value{ name = name, typeOf = typeOf, access = Local {addr = ref ~1 (* Must be set later *), level = ref baseLevel},
                    class = class, locations = locations, references = makeRef() }
    in
        val mkValVar = makeLocalV ValBound
        and mkPattVar = makeLocalV PattBound
    end

    (* Value in a local structure or a functor argument.  May be simple value, exception
        or constructor. *)
    fun mkSelectedVar (Value { access = Formal addr, name, typeOf, class, locations, ...}, Struct{access=sAccess, ...}, openLocs) =
        (* If the argument is "formal" set the base to the base structure. *)
        let
            (* If the base structure is a constant do the selection now.  This is redundant
               unless we're being called from PolyML.NameSpace.Structures.contents.  *)
            val access =
                case sAccess of
                    Global code => Global(mkInd (addr, code))
                |   _ => Selected{addr=addr, base=sAccess}
        in
            Value{name=name, typeOf=typeOf, class=class, access=access,
                  locations=openLocs @ locations, references = NONE}
        end

    |   mkSelectedVar (Value { access = Global code, name, typeOf, class, locations, ...}, _, openLocs) =
        (* Global: We need to add the location information. *)
        Value{name=name, typeOf=typeOf, class=class, access=Global code,
              locations=openLocs @ locations, references = NONE}

    |   mkSelectedVar(selected, _, _) = selected (* Overloaded? *);

    (* Construct a global exception. *)
    fun mkGex (name, typeof, nullary, code, locations) =
        Value{ name = name, typeOf = typeof, access = Global code,
           class = Exception{nullary=nullary}, locations = locations, references = NONE }
 
    (* Construct a local exception. *)
    fun mkEx (name, typeof, nullary, locations) = 
        Value{ name = name, typeOf = typeof,
           access = Local{addr = ref 0, level = ref baseLevel},
           class = Exception{nullary=nullary}, locations=locations, references = NONE }

    (* Locations in exception packets.  In order to have a defined ordering of the fields,
       when we put the location in an exception packet we use this datatype rather than
       the "location" type. *)
     (* *)
    datatype RuntimeLocation =
        NoLocation
    |   SomeLocation of
            (* file: *) string * 
            (*startLine:*) int *  (*startPosition:*) int *
            (*endLine:*) int * (*endPosition:*) int

    fun codeLocation({file="", startLine=0, startPosition=0, ...}) =
        mkConst(toMachineWord NoLocation) (* No useful information *)
    |   codeLocation({file, startLine, startPosition, endLine, endPosition}) =
        mkConst(toMachineWord(file, startLine, startPosition, endLine, endPosition))

(*****************************************************************************)
  (* Look-up functions. *)

    (* These are used locally and also exported to INITIALISE to be used in PolyML.NameSpace.Structures.contents. *)
    fun makeSelectedValue(
            Value{ name, typeOf=ValueType(typeOf, templates), access, class, locations, ... },
            baseStruct as Struct{signat=Signatures { typeIdMap, ...}, name=baseName, ...}) =
    let
        (* This is copied to instantiate bound type constructor IDs in the signature to the actual IDs
           used in this particular structure instance. *)
        fun copyId(TypeId{idKind=Bound{ offset, ...}, ...}) = SOME(typeIdMap offset)
        |   copyId _ = NONE
        val copiedType =
            copyType (typeOf, fn _ => NONE,
                fn tcon => copyTypeConstr (tcon, copyId, fn s => baseName^"."^s))                            
        val baseLoc =
            case List.find (fn DeclaredAt _ => true | _ => false) locations of
                SOME (DeclaredAt loc) => [StructureAt loc]
            |   _ => []
    in
        mkSelectedVar (
                Value{ name=name, typeOf=ValueType(copiedType, templates), access=access, class=class, locations=locations,
                       references = NONE },
                baseStruct, baseLoc)
    end

    fun makeSelectedStructure(
            Struct {signat, access, name=structName, locations, ...},
            Struct {signat=Signatures { typeIdMap, firstBoundIndex, ...}, access=baseAccess, ...}) =
    let
        val Signatures { name=sigName, tab, typeIdMap = childMap, locations=sigLocs, ... } = signat
        (* We need to apply the map from the parent structure to the child. *)
        val copiedSig =
            makeSignature(sigName, tab, firstBoundIndex, sigLocs, composeMaps(childMap, typeIdMap), [])
        (* Convert Formal access to Selected and leave the others (Global?).  If this is
           Formal but the base structure is global do the selection now.  This is only needed
           if we're called from PolyML.NameSpace.Structures.contents. *)
        val newAccess =
            case (access, baseAccess) of
                (Formal sel, Global code) => Global(mkInd(sel, code))
            |   (Formal sel, baseAccess) => Selected { addr = sel, base = baseAccess }
            |   (access, _) => access
        (* If we have a DeclaredAt location for the structure use this as the StructureAt.*)
        val baseLoc =
        case List.find (fn DeclaredAt _ => true | _ => false) locations of
            SOME (DeclaredAt loc) => [StructureAt loc]
        |   _ => []
    in
        Struct { name = structName, signat = copiedSig, access = newAccess, locations = baseLoc @ locations}
    end
    
    fun makeSelectedType(typeConstr, Struct { signat=Signatures { typeIdMap, ...}, name, ...}) =
        fullCopyDatatype(typeConstr, typeIdMap, name^".")

    (* Look up a structure. *)
    fun lookupStructure (kind, {lookupStruct:string -> structVals option},
               name, errorMessage) =
    let
        val {first = prefix, second = suffix} = splitString name;
        val strLookedUp =
            if prefix = ""
            then lookupStruct suffix
            else case lookupStructure
                        ("Structure", {lookupStruct=lookupStruct}, prefix, errorMessage) of
                NONE => NONE (* Already reported *)
            |   SOME(baseStruct as Struct { signat=Signatures { tab, ... }, ...}) =>
                let  (* Look up the first part in the structure environment. *)
                    val Env{lookupStruct, ...} = makeEnv tab
                in
                    case lookupStruct suffix of
                        SOME foundStruct  => SOME(makeSelectedStructure(foundStruct, baseStruct))
                    |   NONE => NONE
                end
    in
        case strLookedUp of
           SOME s => SOME s
        |  NONE =>
             (* Not declared? *)
                (errorMessage (kind ^ " (" ^ suffix ^  ") has not been declared" ^
                   (if prefix = "" then "" else " in structure " ^ prefix));
                NONE)
    end

    fun mkEnv x = let val Env e = makeEnv x in e end

    (* Look up a structure but ignore the access. This is used in sharing constraints
       where we're only interested in the signature. *)
    (* It's simpler to use the common code for this. *)
    fun lookupStructureAsSignature (lookupStruct, name, errorMessage) =
        lookupStructure("Structure", { lookupStruct = lookupStruct}, name, errorMessage)

    (* Look up a value, possibly in a structure. If it is in
       a structure we may have to apply a selection. *)
    fun lookupValue (kind, {lookupVal,lookupStruct}, name, errorMessage) =
    let
        val {first = prefix, second = suffix} = splitString name;
        val found =
        if prefix = "" then lookupVal suffix
        (* Look up the first part in the structure environment. *)
        else case lookupStructure
                    ("Structure", {lookupStruct=lookupStruct}, prefix, errorMessage) of
            NONE => SOME undefinedValue
        |   SOME (baseStruct as Struct { signat=Signatures { tab, ...}, ...}) =>
            (
                case #lookupVal (mkEnv tab) suffix of
                    SOME foundValue => SOME(makeSelectedValue(foundValue, baseStruct))
                |   NONE => NONE
            )
    in
        case found of
            SOME v => v
        |   NONE => (* Not declared? *)
            (
                errorMessage (kind ^ " (" ^ suffix ^ ") has not been declared" ^
                    (if prefix = "" then "" else " in structure " ^ prefix));
                undefinedValue
            )
    end

    fun lookupTyp ({lookupType,lookupStruct}, name, errorMessage) =
    let
        val {first = prefix, second = suffix} = splitString name;
        val found =
        if prefix = "" then lookupType suffix
        else (* Look up the first part in the structure environment. *)
            case lookupStructure
                    ("Structure", {lookupStruct=lookupStruct}, prefix, errorMessage) of
            NONE => SOME(TypeConstrSet(undefConstr, []))
        |   SOME (baseStruct as Struct { signat=Signatures { tab, ...}, ...}) =>
            (
                case #lookupType (mkEnv tab) suffix of
                    SOME typeConstr => SOME(makeSelectedType(typeConstr, baseStruct))
                |   NONE => NONE
            )
    in
        case found of
            SOME v => v
        |   NONE => (* Not declared? *)
            (
                errorMessage ("Type constructor" ^ " (" ^ suffix ^ ") has not been declared" ^
                (if prefix = "" then "" else " in structure " ^ prefix));
                TypeConstrSet(undefConstr, [])
            )
    end 
 
      (* Printing. *)


    (* Print a value given its type. *)
    fun printValueForType (value:machineWord, (types, _), depth): pretty =
    let
        (* Constuct printer code applied to the argument and the depth.
           Code-generate and evaluate it. *)
        val addrs = ref 0 (* Make local declarations for any type values. *)
        val polyCode = mkConst value
        val printerCode =
            mkEval(
                printerForType(types, baseLevel),
                [mkTuple[polyCode, mkConst(toMachineWord depth)]])
        val pretty =
            RunCall.unsafeCast(valOf(evalue(genCode(printerCode, [], !addrs)())))
    in
        pretty
    end

    (* These are used to display the declarations made. *)
    fun displayFixStatus(FixStatus(name, f)): pretty =
    let
        open PRETTY
        
        val status =
            case f of
                Nonfix => PrettyString "nonfix"
            |   Infix prec =>
                    PrettyBlock(0, false, [],
                        [ PrettyString "infix", PrettyBreak (1, 0), PrettyString (Int.toString prec) ])
            |   InfixR prec =>
                    PrettyBlock(0, false, [],
                        [ PrettyString "infixr", PrettyBreak (1, 0), PrettyString (Int.toString prec) ])
    in
        PrettyBlock (0, false, [],
            [status, PrettyBreak (1, 0), PrettyString name])
    end

    (* Returns the declaration location as the location for the context. *)
    fun getLocation locations =
        case List.find(fn DeclaredAt _ => true | _ => false) locations of
            SOME(DeclaredAt loc) => [ContextLocation loc]
        |   _ => []


    (* Displays value as a block, with no external formatting.  This is used at the
       top level but it can be applied to values extracted with #lookup globalNameSpace.
       That can include constructors and overloaded functions. *)
    fun displayValues (Value{name, typeOf=ValueType(valType as (typeOf, _)), class, access, locations, ...}, depth: FixedInt.int, nameSpace, sigMap): pretty =
    let
        (* Create the "val X =" part. *)
        fun valPart (valOrCons, isColon) =
        let
            (* If we're putting in a colon we don't need a space after an alphanumeric id but we
               do if it's symbolic. *)
            val isAlphaNumeric =
                let val first = String.sub(name, 0) in Char.isAlpha first orelse first = #"'" end
            val space =
                if isColon andalso isAlphaNumeric then 0 else 1
            val equOrColon = if isColon then ":" else "="
        in
            PrettyBlock (0, false, [],
                [
                    PrettyString valOrCons,
                    PrettyBreak (1, 0),
                    PrettyBlock(0, false, getLocation locations, [PrettyString name]),
                    PrettyBreak (space, 0),
                    PrettyString equOrColon
                ]
            )
        end
        val typeEnv = (* Environment to check for type constructors. *)
            { lookupType = #lookupType nameSpace, lookupStruct = #lookupStruct nameSpace}
    in
  
        if depth <= 0 
        then PrettyString "..."

        else case class of
            ValBound =>
            let
                (* In nearly all cases if we have Global code we will have a constant.
                   There was one case where "!" was actually a Lambda that hadn't been
                   code-generated. *)
                val value =
                    case access of Global code => evalue code | _ => NONE
                val start =
                    case value of
                        SOME v =>
                        [
                            valPart("val", false),
                            PrettyBreak (1, 0),
                            printValueForType (v, valType, depth),
                            PrettyString ":"
                        ]
                    |   _ => [ valPart("val", true) ]
            in
                PrettyBlock (3, false, [],
                    start @ [ PrettyBreak (1, 0), displayWithMap (SimpleInstance typeOf, depth, typeEnv, sigMap) ])
            end

        |    Exception _ => (* exceptions *)
             PrettyBlock (0, false, [],
                PrettyBlock (0, false, [],
                    [
                        PrettyString "exception",
                        PrettyBreak (1, 0),
                        PrettyBlock(0, false, getLocation locations, [PrettyString name])
                    ]
                )
                ::
                (
                    case exceptionArgType typeOf of
                       NONE => []
                    |  SOME excType =>
                        [ PrettyBreak (1, 1), PrettyString "of", PrettyBreak (1, 3), displayWithMap (SimpleInstance  excType, depth, typeEnv, sigMap) ]
                )
            )

        | Constructor _ => (* This can only occur with #lookupVal *)
            PrettyBlock (3, false, [],
                [ valPart("constructor", true), PrettyBreak (1, 0), displayWithMap (SimpleInstance  typeOf, depth, typeEnv, sigMap) ])
     
        | PattBound => (* Can this ever occur? *)
            PrettyBlock (3, false, [],
                [ valPart("val", true), PrettyBreak (1, 0), displayWithMap (SimpleInstance typeOf, depth, typeEnv, sigMap) ])
    end

    (* Print global values.  This is passed through the bootstrap and used in the debugger. *)
    fun printValues (Value{typeOf=ValueType valType, class, access, ...}, depth) =
        case (class, access) of
            (ValBound, Global code) => printValueForType (valOf(evalue code), valType, depth)
        | _ => PrettyString "" (* Probably shouldn't occur. *)

    (* Prints "sig ... end" as a block, with no external formatting *)
    fun displaySig (Signatures{tab, typeIdMap, ...}, depth : FixedInt.int, _ : int,
                    { lookupType, lookupStruct, ...}, sigMap: (int-> typeId) option) : pretty =
    let
        (* Construct an environment for the types. *)

        val Env { lookupType = strType, lookupStruct = strStr, ...} = makeEnv tab

        (* Construct a map for types. *)
        val innerMap =
            case sigMap of
                NONE => SOME typeIdMap
            |   SOME outerMap => SOME(composeMaps(typeIdMap, outerMap))

        val compositeEnv =
        {
            lookupType   =
                fn s => case strType s of NONE => lookupType s | SOME t => SOME (t, innerMap),
            lookupStruct =
                fn s => case strStr s of NONE => lookupStruct s | SOME s => SOME (s, innerMap)
        }
        
        val typeEnv: printTypeEnv =
            { lookupType = #lookupType compositeEnv, lookupStruct = #lookupStruct compositeEnv }

        fun displaySpec (_, value) : pretty list =
        if (tagIs signatureVar value)
        then (* Not legal ML97 *)
            [ PrettyBreak(1,2), displaySignatures (tagProject signatureVar value, depth - 1, compositeEnv)]
           
        else if (tagIs structVar value)
        then
            [ PrettyBreak(1,2), displayStructures (tagProject structVar value, depth - 1, compositeEnv, innerMap)]
               
        else if (tagIs typeConstrVar value)
        then 
            [ PrettyBreak(1,2), displayTypeConstrsWithMap (tagProject typeConstrVar value, depth, typeEnv, innerMap) ]
      
        else if (tagIs valueVar value)
        then
        let
            (* Only print variables. Constructors are printed with their type. *)
            val value = tagProject valueVar value;
        in
            case value of
                Value{class = Constructor _, ...} => []
            |    _ =>
              [ PrettyBreak(1,2),
              (* We lookup the infix status and any exception in the global environment
                 only.  Infix status isn't a property of a structure and it's too
                 much trouble to look up exceptions in the structure. *)
                displayValues (value, depth, compositeEnv, innerMap)
              ]
        end
      
        else if (tagIs fixVar value)
        then  (* Not legal ML97 *)
            [ PrettyBreak(1,2), displayFixStatus (tagProject fixVar value) ]
 
        else []
       (* end displaySpec *)
    in
        PrettyBlock (0, true, [],
            PrettyString "sig" ::
            (
                (
                    if depth <= 1 (* If the depth is 1 each of the calls to displaySpec will
                                     print "..." so we replace them all by a single "..." here. *)
                    then [PrettyBreak (1, 0), PrettyString "..."]
                    else
                    let
                        val declist = ref nil : (string * universal) list ref
                        fun addToList nv = declist := nv :: !declist
                        (* For the moment order them by name.  We may change this to
                           order primarily by kind and secondarily by name. *)
                        fun order (s1: string, _) (s2: string, _) = s1 > s2
                    in
                        (* Put all the entries into a list. *)
                        UNIVERSALTABLE.app addToList tab;
                        (* Sort the list and print it. *)
                        List.foldl
                            (fn (a, l) => displaySpec a @ l)
                            [] (quickSort order (!declist))
                    end
                )
                @ [PrettyBreak (1, 0), PrettyString "end"]
            )
        )
        end (* displaySig *)

  (* Print: signature S = sig .... end *)
  and displaySignatures (str as Signatures{locations, name, ...}, depth : FixedInt.int, nameSpace) : pretty =
    if depth <= 0 then PrettyString "..."
    else
        PrettyBlock(0, false, [],
            [
                PrettyBlock(0, false, [],
                    [
                        PrettyString "signature",
                        PrettyBreak(1, 0),
                        PrettyBlock(0, false, getLocation locations, [PrettyString name]),
                        PrettyBreak(1, 0),
                        PrettyString "="
                    ]
                ),
            PrettyBreak (1, 2),
            displaySig (str, depth, 1, nameSpace, NONE)
            ])

  (* print structure in a block (no external spacing) *)
    and displayStructures (Struct{name, locations, signat, ...}, depth, nameSpace, sigMap): pretty =
    if depth <= 0 then PrettyString "..."
    else
        PrettyBlock (0, false, [],
        [
            PrettyBlock(0, false, [],
                [
                    PrettyString "structure",
                    PrettyBreak(1, 0),
                    PrettyBlock(0, false, getLocation locations, [PrettyString name]),
                    PrettyBreak(0, 0),
                    PrettyString ":"
                ]
            ),
            PrettyBreak(1, 2),
            displayNamedSig(signat, depth - 1, 1, nameSpace, sigMap)
        ])

    (* Internal function for printing structures and functors.  If a signature has a
       name print the name rather than the contents. *)
    and displayNamedSig(sign as Signatures{name = "", ...}, depth, space, nameSpace, sigMap) =
            displaySig (sign, depth, space, nameSpace, sigMap)
    |   displayNamedSig(Signatures{name, ...}, _, _, _, _) = PrettyString name

    fun displayFunctors (Functor{ name, locations, arg, result, ...}, depth, nameSpace) =
    if depth <= 0 then PrettyString "..."
    else
    let
        val arg as 
             Struct { name = argName, signat as Signatures { tab = argTab, ... }, ...} = arg
        val argEntries =
            (if argName <> ""
            then [ PrettyBlock(0, false, [], [PrettyString argName, PrettyBreak(0, 0), PrettyString ":"]), PrettyBreak(1, 2) ]
            else []) @
            [
                displayNamedSig (signat, depth - 1, 0, nameSpace, NONE),
                PrettyBreak(0, 0),
                PrettyString "):",
                PrettyBreak(1, 0)
            ]
        (* Include the argument structure name in the type environment. *)
        val argEnv =
            if argName = ""
            then
            let
                val Env { lookupType=lt, lookupStruct=ls, ...} = makeEnv argTab
            in
                {
                    lookupType =
                        fn s => case lt s of NONE => #lookupType nameSpace s | SOME t => SOME(t, NONE),
                    lookupStruct =
                        fn s => case ls s  of NONE => #lookupStruct nameSpace s | SOME s => SOME(s, NONE)
                }
            end
            else
            {
                lookupType   = #lookupType nameSpace,
                lookupStruct =
                    fn s => if s = argName then SOME(arg, NONE) else #lookupStruct nameSpace s
            }
    in
        PrettyBlock (0, false, [],
            [
                PrettyBlock(0, false, [],
                [
                    PrettyBlock(0, false, [],
                    [
                        PrettyString "functor",
                        PrettyBreak(1, 0),
                        PrettyBlock(0, false, getLocation locations, [PrettyString name]),
                        PrettyBreak(1, 0),
                        PrettyString "("
                    ]),
                    PrettyBreak(0, 2),
                    PrettyBlock(0, false, [], argEntries)
                ]),
                PrettyBreak(0, 2),
                displayNamedSig (result, depth - 1, 1, argEnv, NONE)
            ]
        )
    end

    (* Exported version. *)
    val displayValues = fn (value, depth, nameSpace) => displayValues (value, depth, nameSpace, NONE)
    and displayStructures = fn (str, depth, nameSpace) => displayStructures (str, depth, nameSpace, NONE)
   
  (* Code-generation. *)

    (* Code-generate the values. *) 
    fun codeStruct (Struct{access, ...}, level) =
        (* Global structures have no code value. Instead the
            values are held in the values of the signature. *)
        codeAccess (access, level)

    and codeAccess (Global code, _) = code
      
    |   codeAccess (Local{addr=ref locAddr, level=ref locLevel}, level) =
            mkLoad (locAddr, level, locLevel) (* Argument or local *)
     
    |   codeAccess (Selected{addr, base}, level) = (* Select from a structure. *)
            mkInd (addr, codeAccess (base, level))
     
    | codeAccess _ = raise InternalError "No access"

(*****************************************************************************)
(*                  datatype access functions                                *)
(*****************************************************************************)

    (* Get the appropriate instance of an overloaded function.  If the
       overloading has not resolved to a single type it finds the preferred
       type if possible (i.e. int for most overloadings, but possibly real,
       word, string or char for conversion functions.) *)
    fun getOverloadInstance(name, instance): codetree * string =
    let
        val constr = typeConstrFromOverload instance
        val tcName = case constr of TypeConstrs {name,...}  => name
        open Overloads
    in
        (getOverloadCode(name, constr), tcName)
    end

    (* This is only used in addPrettyPrint.  There's no point in
       producing a lot of detailed information. *)
    fun checkPPType (instanceType, matchType, fnName, lex, location, moreInfo) =
        case unifyTypes (instanceType, matchType) of
            NONE => ()
        |   SOME error =>
            let
                open DEBUG
                val parameters = LEX.debugParams lex
                val errorDepth = getParameter errorDepthTag parameters
            in
                reportError lex
                {
                    location = location,
                    hard = true,
                    message =
                        PrettyBlock(0, true, [],
                            [
                                PrettyString ("Argument for " ^ fnName),
                                PrettyBreak (1, 3),
                                PrettyBlock(0, false, [],
                                    [
                                        PrettyString "Required type:",
                                        PrettyBreak (1, 0),
                                        display (matchType, errorDepth, emptyTypeEnv)
                                    ]),
                                PrettyBreak (1, 3),
                                PrettyBlock(0, false, [],
                                    [
                                        PrettyString "Argument type:",
                                        PrettyBreak (1, 0),
                                        display (instanceType, errorDepth, emptyTypeEnv)
                                    ]),
                                PrettyBreak (1, 3),
                                unifyTypesErrorReport(lex, emptyTypeEnv, emptyTypeEnv, "unify") error
                            ]),
                    context = SOME (moreInfo ())
               }
            end

    val arg1     = mkLoadArgument 0 (* saves a lot of garbage *)

    (* Code-generate an identifier matched to a value.  N.B. If the value is a
       constructor it returns the pair or triple representing the functions on the
       constructor. *)
    fun codeVal (Value{access = Global code, ...}, _, _, _, _) = code

    |   codeVal (Value{access = Local{addr=ref locAddr, level=ref locLevel}, ...}, level, _, _, _) =
            mkLoad (locAddr, level, locLevel) (* Argument or local *)

    |   codeVal (Value{access = Selected{addr, base}, ...}, level: level, _, _, _) =
            (* Select from a structure. *)
            mkInd (addr, codeAccess (base, level))

    |   codeVal (Value{access = Formal _, ...}, _, _, _, _) =
            raise InternalError "codeVal - Formal"

    |   codeVal (Value{access = Overloaded Print, ...}, _, [], lex, _) =
        (* If this appears in a structure return a null printer function.
           It has to have the polymorphic form with an extra lambda outside. *)
        let
            (* We should have a single entry for the type. *)
            open DEBUG
            (* The parameter is the reference used to control the print depth
               when the value is actually printed. *)
            val prettyOut = getPrintOutput (LEX.debugParams lex)
            val printFun =
                mkProc(
                    CODETREE.mkEnv
                    (
                        [
                            mkNullDec
                            (mkEval(
                                mkConst(toMachineWord prettyOut),
                                [ mkConst(toMachineWord(PrettyString "?")) ])
                            )
                        ],
                        arg1 (* Returns its argument. *)
                    ),
                    1, "print()", [], 0)            
        in
            printFun
        end

    |   codeVal (Value{access = Overloaded Print, ...}, level: level, [argType], lex, _) =
        let 
            (* We should have a single entry for the type. *)
            open DEBUG
            (* The parameter is the reference used to control the print depth
               when the value is actually printed. *)
            val printDepthFun = getParameter printDepthFunTag (LEX.debugParams lex)
            and prettyOut = getPrintOutput (LEX.debugParams lex)
            val nLevel = newLevel level
        in
            (* Construct a function that gets the print code, prints it out and returns
               its argument. *)
            mkProc(
                CODETREE.mkEnv
                (
                    [
                        mkNullDec (
                            mkEval(
                                mkConst(toMachineWord prettyOut),
                                [
                                    mkEval(
                                        printerForType(argType, nLevel),
                                        [
                                            mkTuple[arg1,
                                                mkEval(mkConst(toMachineWord printDepthFun), [CodeZero])]
                                        ])
                                ])
                        )
                    ],
                    arg1 (* Returns its argument. *)
                ),
                1, "print()", getClosure nLevel, 0)
        end

    |   codeVal (Value{access = Overloaded Print, ...}, _, _, _, _) =
            raise InternalError "Overloaded Print - wrong instance type"

    |   codeVal (Value{access = Overloaded MakeString, ...}, _, [], _, _) =
        (* If this appears in a structure produce a default version. *)
            mkProc(mkConst(toMachineWord "?"), 1, "makestring()", [], 0)

    |   codeVal (Value{access = Overloaded MakeString, ...}, level: level, [argType], _, _) =
        let
            val nLevel = newLevel level
        in
            (* Construct a function that gets the print code and prints it out using "uglyPrint". *)
            mkProc(
                mkEval(
                    mkConst(toMachineWord uglyPrint),
                    [
                        mkEval(
                            printerForType(argType, nLevel),
                            [
                                mkTuple[arg1, mkConst(toMachineWord 10000)]
                            ])
                    ]),
                1, "makestring()", getClosure nLevel, 0)
        end

    |   codeVal (Value{access = Overloaded MakeString, ...}, _, _, _, _) =
            raise InternalError "Overloaded MakeString - wrong instance type"

    |   codeVal (Value{access = Overloaded GetPretty, ...}, level, [], _, _) =
        let
            val nLevel = newLevel level
        in
            (* If this appears in a structure return a default function. *)
            mkProc(printerForType(BadType, nLevel), 1, "getPretty", getClosure nLevel, 0)
        end

    |  codeVal (Value{access = Overloaded GetPretty, ...}, level: level, [argType], _, _) =
       (* Get the pretty code for the specified argument. *)
            printerForType(argType, level)

    |   codeVal (Value{access = Overloaded GetPretty, ...}, _, _, _, _) =
            raise InternalError "Overloaded GetPretty - wrong instance type"

    |   codeVal (Value{access = Overloaded AddPretty, ...}, _, [], _, _) =
            (* If this appears in a structure create a function that raises an exception if run. *)
            mkConst (toMachineWord (fn _ => raise Fail "addPrettyPrint: The argument type was not a simple type construction"))

    |   codeVal (Value{access = Overloaded AddPretty, ...}, level: level, [installType, argPrints], lex, loc) =
        let 
         (* "instance" should be (int-> 'a -> 'b -> pretty) -> unit.
             We need to get the 'a and 'b.  This function installs a
             pretty printer against the type which matches 'b.
             The type 'a is related to type of 'b as follows:
             If 'b is a monotype t then 'a is ignored.
             If 'b is a unary type constructor 'c t then 'a must have
             type 'c * int -> pretty.
             If 'b is a binary or higher type constructor e.g. ('c, 'd, 'e) t
             then 'a must be a tuple of functions of the form
             ('c * int -> pretty, 'd * int -> pretty, 'e * int -> pretty).
             When the installed function is called it will be passed the
             appropriate argument functions which it can call to print the
             argument types.  *)
            val pretty = mkTypeVar (Generalisable, false)

            (* Find the last type constructor in the chain. We have to install
                 this against the last in the chain because type constructors in
                 different modules may be at different points in the chain. *)
              (* This does mean that it's not possible to install a
                 pretty printer for a type constructor rather than a datatype. *)
            fun followTypes (TypeConstruction{constr as TypeConstrs {identifier = TypeId{idKind = TypeFn _, ...},...}, args, ...}) =
                    followTypes (makeEquivalent (constr, args))
            |   followTypes (TypeConstruction{constr as TypeConstrs {identifier,...}, args, ...}) =
                    SOME(identifier, constr, List.length args)
            |   followTypes (TypeVar(TypeVariable{link=ref l, ...})) = Option.composePartial(followTypes o instanceToType, followRefChainToEnd) l
            |   followTypes _ = NONE;

            val constrId = followTypes installType
            
            val () =
                case constrId of
                    SOME (_, constr as TypeConstrs {name=tcName,...}, arity) =>
                    let
                        (* Check that the function tuple matches the arguments of the type
                           we're installing for. *)
                        (* Each entry should be a function of type 'a * int -> pretty *)
                        fun mkFn arg = mkFunctionType(mkProductType[arg, TYPESTRUCT.fixedIntType], pretty)
                        (* Create non-unifiable type vars to ensure this is properly polymorphic. *)
                        val typeVars =
                            List.tabulate(arity,
                                fn n => FreeTypeVar{ name = makeTypeVariableName(n, false), equality=false, level=NotGeneralisable 0, uid=makeUniqueId() })
                        val tupleType =
                            case typeVars of
                                [] => (* No arg so must have unit. *) unitType
                            |   [arg] => mkFn arg (* Just a single function. *)
                            |   args => mkProductType(List.map mkFn args)
                        val addPPType = mkFunctionType(argPrints, mkFunctionType(installType, pretty))
                        val testType = mkFunctionType(tupleType,
                            mkFunctionType(
                                mkTypeConstruction(tcName, constr, typeVars, [DeclaredAt loc]),
                                pretty))
                    in
                        checkPPType(SimpleInstance addPPType, SimpleInstance testType, "addPrettyPrint", lex, loc,
                            fn () =>
                                PrettyString "addPrettyPrint element functions must have type 'a * int -> pretty, 'b * int -> pretty, ... with one function for each type parameter")
                    end
                |   _ => ()

            (* Only report the error when the function is run.  Because addPrettyPrint is
               contained in the PolyML structure we may compile a reference to a polymorphic
               version of this for the structure record.  It's replaced in the final structure
               by this version. *)
        in
            case constrId of
                SOME (TypeId { access=typeIdAccess, ...}, _, arity) =>
                    let
                        (* We need to transform the user-supplied function into the form required for
                           the reference.   The user function has type int -> 'b -> 'a -> pretty
                           where 'b is either "don't care" if this is a monotype, the print function
                           for the base type if it takes a single type argument or a tuple of base type
                           functions if it takes more than one.  The reference expects to contain a
                           function of type 'a * int -> pretty for a monotype or a function of the
                           form <'b1, 'b2...> -> 'a * int -> pretty if this is polytype where
                           <...> represents poly-style multiple arguments.  *)
                        val printFunction =
                            case arity of
                                0 => 
                                    mkProc(
                                        mkEval(
                                            mkEval(
                                                mkEval(
                                                    mkLoadClosure 0 (* The user-supplied fn *),
                                                    [mkInd(1, arg1)] (* The depth *)),
                                                [CodeZero] (* Ignored args. *)),
                                            [mkInd(0, arg1)] (* Value to print *)),
                                        1, "addPP-1", [arg1](* The user-supplied fn *), 0)

                            |   arity =>
                                let
                                    open TypeValue
                                    val args =
                                        if arity = 1
                                        then [extractPrinter(mkLoadClosure 1)]
                                        else [mkTuple(List.tabulate(arity, fn n => extractPrinter(mkLoadClosure(n+1))))]
                                in
                                    mkProc(
                                        mkProc(
                                            mkEval(
                                                mkEval(
                                                    mkEval(
                                                        mkLoadClosure 0 (* The user-supplied fn *),
                                                        [mkInd(1, arg1)] (* The depth *)),
                                                    args (* Base fns. *)),
                                                [mkInd(0, arg1)] (* Value to print *)),
                                            1, "addPP-2", mkLoadClosure 0 :: List.tabulate(arity, mkLoadArgument), 0),
                                        arity, "addPP-1", [arg1], 0)
                                end
                        val nLevel = newLevel level
                    in
                        (* Generate a function that will set the "print" ref for the type to
                           the argument function. *)
                        mkProc(
                            mkStoreOperation(LoadStoreMLWord{isImmutable=false},
                                TypeValue.extractPrinter(
                                    codeAccess(typeIdAccess, nLevel)), CodeZero, printFunction
                                ), 1, "addPP", getClosure nLevel, 0)
                    end

            |   NONE =>
                    mkConst (toMachineWord
                        (fn _ => raise Fail "addPrettyPrint: The argument type was not a simple type construction"))
        end

    |   codeVal (Value{access = Overloaded AddPretty, ...}, _, _, _, _) =
        raise InternalError "Overloaded AddPretty - wrong instance type"

    |  codeVal (Value{access = Overloaded GetLocation, ...}, _, _, _, _) =
        (* This can't be used a value: It must be called immediately. *)
        let
            fun getLoc() =
                raise Fail "The special function PolyML.sourceLocation cannot be used as a value"
        in
            mkConst (toMachineWord getLoc)
        end

    |   codeVal (value as Value{access = Overloaded _, ...}, level: level, instance, lex, lineno) =
        let
            val nLevel = newLevel level
        in
            (* AddOverload, Equal, NotEqual, TypeDep *)
            mkProc(applyFunction (value, arg1, nLevel, instance, lex, lineno), 1, "", getClosure nLevel, 0)
        end

    (* Some of these have a more efficient way of calling them as functions. *)
    and applyFunction (value as Value{class=Exception _, ...}, argument, level, instance: types list, lex, lineno) =
        let
        (* If we are applying it as a function we cannot be after the
          exception id, we must be constructing an exception packet. *)
        (* Get the exception id, put it in the packet with the exception name
          the argument and, currently, an empty location as the exception location. *)
            val exIden = codeVal (value, level, instance, lex, lineno);
            fun valName (Value{name, ...}) = name
        in
            mkTuple (exIden :: mkStr (valName value) :: argument :: [mkConst(toMachineWord NoLocation)])
        end

    |   applyFunction(value as Value{class=Constructor _, ...}, argument, level, _, lex, lineno) =
        let
            (* If this is a value constructor we need to get the construction
               function and use that. *)
            val polyConstr = ValueConstructor.extractInjection(codeVal (value, level, [], lex, lineno))
        in
             (* Don't apply this "early".  It might be the ref constructor and that
               must not be applied until run-time.  The optimiser should take care
               of any other cases. *)
            mkEval (polyConstr, [argument])
        end

    |   applyFunction (value as Value{access = Overloaded oper, name = valName, ...},
                     argument, level, instance, lex, lineno) =
        (
            case oper of
                Equal => (* Get the equality function for the type. *)
                let
                    (* We should have a single entry for the type. *)
                    val argType =
                        case instance of
                            [value] => value
                        |   _ => raise InternalError "Overload Equal"
                    (* The instance type is a function so we have to get the first argument. *)
                    val code = equalityForType(argType, level)
                in
                    mkEval (code, [argument])
                end
        
            |   NotEqual =>
                let
                    (* We should have a single entry for the type. *)
                    val argType =
                        case instance of
                            [value] => value
                        |   _ => raise InternalError "Overload NotEqual"
                    (* Use the "=" function to provide inequality as well as equality. *)
                    val code = equalityForType(argType, level)
                    val isEqual = mkEval (code, [argument])
                in
                    mkNot isEqual
                end
       
            |   TypeDep =>
                let (* Overloaded functions e.g +,*,abs *)
                    val argType =
                        case instance of
                            [value] => value
                        |   _ => raise InternalError "Overload TypeDep"
                    val (code, _) = getOverloadInstance(valName, argType)
                in
                    mkEval (code, [argument])
                end

            |   AddOverload =>
                (* AddOverload is only intended for use by writers of library modules.
                   It only does limited checking and should be regarded as "unsafe". *)
                let
                    fun rmvars (TypeVar(TypeVariable{link=ref l, ...})) =
                            (case followRefChainToEnd l of NONE => BadType | SOME t => rmvars(instanceToType t))
                    |   rmvars t = t
                    (* instance should be ('a->'b) -> string -> unit.  For overloadings
                       on most functions (e.g. abs and +) we are looking for the 'a, which
                       may be a pair, but in the case of conversion functions we want the 'b. *)
                    val (resultType, argType) =
                        case instance of
                            [alpha, beta] => (rmvars alpha, rmvars beta)
                        |   _ => (BadType, BadType)

                    fun followTypes(TypeConstruction{constr as TypeConstrs {identifier = TypeId{idKind = Free _, ...},...}, ...}) = constr
 
                    |   followTypes(TypeConstruction{constr as TypeConstrs {identifier = TypeId{idKind = TypeFn _, ...},...}, args, ...}) =
                            followTypes (makeEquivalent (constr, args))

                    |   followTypes(TypeConstruction{constr = TypeConstrs {identifier = TypeId{idKind = Bound _, ...},...}, ...}) =
                           raise Fail "Cannot install an overload within a structure or functor"

                    |   followTypes _ = raise Fail "Invalid type (not a type construction) (addOverload)"

                    fun addOverloading (argCode: codetree) (name: string) =
                        let
                            val typeToUse =
                                if size name > 4 andalso
                                    String.substring(name, 0, 4) = "conv"
                                (* For conversion functions it's the result type we're interested in.
                                   For everything else it's the argument type.  This will be a pair
                                   for functions such as "+" and a single argument for "abs". *)
                                then resultType
                                else case argType of
                                    LabelledRecord[{typeOf, ...}, _] => rmvars typeOf
                                |   argType => argType
                            
                            val tcons = followTypes typeToUse
                        in
                            Overloads.addOverload(name, tcons, argCode)
                        end

                    (* This function is used if we can't get the codetree at
                       compile time. *)
                    fun addOverloadGeneral (arg: machineWord) =
                        addOverloading(mkConst arg)
                in
                (* This is messy but necessary for efficiency.  If we simply treat
                   addOverload as a function we would be able to pick up the
                   additional overloading as a pointer to a function.  Most overloads
                   are small functions or wrapped calls to built-in functions and so
                   we need to get the inline code for them. *)
                        (* evalue raises an exception if "argument" is not a constant,
                          or more usefully, a global value containing a constant and
                          possibly a piece of codetree to inline. *)
                  case evalue(argument) of
                    SOME _ => mkConst (toMachineWord (addOverloading argument))
                  | NONE => mkEval (mkConst (toMachineWord addOverloadGeneral), [argument])
                end

        |   GetLocation => (* Return the current location. *) mkConst(toMachineWord lineno)
        
        |   _ => (* Print, MakeString, InstallPP *)
            (* Just call as functions. *)
                mkEval (codeVal (value, level, instance, lex, lineno), [argument])
            
        ) (* overloaded *)
     
    |   applyFunction (value, argument, level, instance, lex, lineno) =
            mkEval (codeVal (value, level, instance, lex, lineno), [argument])
    (* end applyFunction *)

  (* If the exception is being used as a value we want an exception packet
     or a function to make a packet. If it is a nullary constructor make
     an exception packet now, otherwise generate a function to construct
     an exception packet. *)
    fun codeExFunction (value as Value{typeOf=ValueType(typeOf, _), ...}, level, instance, nullary, lex, lineno) =
        if nullary
        then applyFunction (value, CodeZero, level, instance, lex, lineno)
        else
        let
            val nLevel = newLevel level
        in
            mkProc 
              (applyFunction (value, arg1, nLevel, instance, lex, lineno),
                1, "", getClosure nLevel, 0)
        end

    (* Operations to compile code from the representation of a constructor. *)
    (* Code to test whether a value matches a constructor.
       This must be applied to any polymorphic variables in the instance but the
       result is always bool so we don't create a new function if the result is
       also polymorphic.
       It is just possible to have a resulting polytype here
       (N.B. that's different from having a parametric type) if we have a val binding.
        e.g. val SOME x = SOME nil.  In that case we can choose an arbitrary type
        for the test and have to parameterise the result.     *)
    fun makeGuard (value as Value{class=Constructor _, ...}, testing, level) =
        let
            val testCode = ValueConstructor.extractTest(codeVal (value, level, [], nullLex, location nullLex))
        in
            mkEval(testCode, [testing])
        end

    |   makeGuard (value as Value{class=Exception _, ...}, testing, level) =
        (* Should only be an exception. Get the value of the exception identifier 
           and compare with the identifier in the exception packet. *)
        mkEqualPointerOrWord (mkInd (0, testing),
                        codeVal (value, level, [], nullLex, location nullLex))

    |   makeGuard _ = raise InternalError "makeGuard"

    (* Code to invert a constructor. i.e. return the value originally used as the argument.
       Apply to any polymorphic variables and construct a result. *)
    fun makeInverse(value as Value{class=Constructor{nullary=false, ...}, ...}, arg, level): codetree =
        let
            val loadCode = ValueConstructor.extractProjection(codeVal (value, level, [], nullLex, location nullLex))
        in
            mkEval(loadCode, [arg])
        end

    |  makeInverse(Value{class=Constructor{nullary=true, ...}, ...}, _, _): codetree =
        (* makeInverse is called even on nullary constructors.  Return zero to keep the
           optimiser happy. *) CodeZero

    |   makeInverse (Value{class=Exception _, ...}, arg, _) =
            (* Exceptions. - Get the parameter from third word *)
            (* We have to use a VarField here even though this field is present in
               every exception.  The format of the value that is returned depends
               on the exception id. *)
            mkVarField (2,arg)

    |   makeInverse _ = raise InternalError "makeInverse"

    (* Convert a literal constant. We can only do this once any overloading
       has been resolved. *)
    fun getLiteralValue(converter, literal, instance, error): machineWord option =
        let
            fun valName (Value{name, ...}) = name
            val (conv, name) =
                 getOverloadInstance(valName converter, instance)
        in
            SOME(RunCall.unsafeCast(valOf(evalue conv)) literal)
                handle Match => NONE (* Overload error *)
                  | Conversion s =>
                        (
                            error("Conversion exception ("^s^") raised while converting " ^
                                    literal ^ " to " ^ name);
                            NONE
                        )
                  | Overflow => 
                        (
                            error ("Overflow exception raised while converting " ^
                                    literal ^ " to " ^ name);
                            NONE
                        )
                  | Thread.Thread.Interrupt => raise Thread.Thread.Interrupt
                  | _ =>
                        (
                            error ("Exception raised while converting " ^
                                    literal ^ " to " ^ name);
                            NONE
                        )
        end

    (* Types that can be shared. *)
    structure Sharing =
    struct
        type lexan          = lexan
        type codetree       = codetree
        type types          = types
        type values         = values
        type structVals     = structVals
        type functors       = functors
        type valAccess      = valAccess
        type typeConstrs    = typeConstrs
        type typeConstrSet  = typeConstrSet
        type signatures     = signatures
        type fixStatus      = fixStatus
        type univTable      = univTable
        type pretty         = pretty
        type locationProp   = locationProp
        type typeId         = typeId
        type level          = level
        type machineWord    = machineWord
        type valueType      = valueType
    end

end (* body of VALUEOPS *);


